---
title: 'React Crashcourse (Part 2): React Core Functionality'
author: Ran Li
date: '2021-10-08'
slug: react-crashcourse-part-2-react-core
categories:
  - React
tags:
  - React
  - Course Notes
subtitle: ''
summary: ''
authors: []
lastmod: '2021-10-08T13:35:41-04:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

**This blog (part 2 of the React Crash-course series) cover the following topics within the context of the course's first mini-project:**

-   **React basics & Working with Components (Section 3)**
-   **User Interactions & State (Section 4)**

# Section 3: React basics & Working with Components

In React we want to split our application into components for reputabilityand Separation **of Concerns**. So we will be building a lot of components. App.js is a special/root component which is rendered in index.js and should stay in root. All other components are either nested in App.js or within components in App.js; we build essentially a component tree where App.js is head of the tree. We build our first custom component and import/insert it into our root component in this [commit](https://github.com/rl627/udemy-react-js-academind/commit/5321bfa2fc5e4dfd243f4a81f9b19e555dfa0fae).

ðŸ¦€Create a ./components folder in your React project to contain the many many component source files you will write.ðŸ¦€

ðŸ¦€The root component (App.js) needs to stay in root.ðŸ¦€

ðŸ¦€Component file and function names should always start with capital letter. This allows react to differentiate JSX tags from HTML tags ðŸ¦€

### Adding Some Complexity to Components

We edit our custom component to be slightly more complex ([commit](https://github.com/rl627/udemy-react-js-academind/commit/92d2d6cb45b8e0098f56342adea9f57c9e31678c)).

``` {.javascript}
function ExpenseItem() {
  return (
    <div>
      <div>May 3, 1932</div>
      <div>
        <h2>Car Insurance</h2>
        <div>$333</div>
      </div>
    </div>
    ) 
}

export default ExpenseItem;
```

ðŸ¦€React components must only have one root element. So nest everything either in a div or a React Fragment ðŸ¦€

### Styling Components

ðŸ¦€ **Creating a css file:** Next to style our components we add a css file with the same file name next to it in the ./component folder. Important: we need to import the css file in the appropriate module. ðŸ¦€

ðŸ¦€ **Importing css into module:** Next to style our components we add a css file with the same file name next to it in the ./component folder. Important: we need to import the css file in the appropriate module. ðŸ¦€

ðŸ¦€ **Defining CSS selectors/classes in JSX:** Note that JSX is different from HTML one of the key differences is that class names are defined with the **className** attribute in JSX (because class is a reserved word in JS). ðŸ¦€

After add a css file, we edit out first component to import and assign classNames for styling ([commit](https://github.com/rl627/udemy-react-js-academind/commit/2a810e214ce3c314c25e1d1256bf4b16ce1adc63))

``` {.javascript}
import './ExpenseItem.css';

function ExpenseItem() {
  return (
    <div className="expense-item">
      <div>May 3, 1932</div>
      <div>
        <h2>Car Insurance</h2>
        <div>$333</div>
      </div>
    </div>
  );
}

export default ExpenseItem;
```

### JS in JSX

Components should be reusable; we want to define the HTML once and reuse it with new/dynamic data. Remember that JSX is a mix of HTML and JS; before we can do data fetching via JS lets first learn how to work with JS within JSX.

ðŸ¦€**We can run JS within JSX by using \`{ }\`** similiar to glue() in R or how we can run JS in backticks.

``` {.javascript}
import './ExpenseItem.css';

function ExpenseItem() {
  const expenseDate = new Date(2021, 2, 28);
  const expenseTitle = 'Car Insurance';
  const expenseAmount = 333;

  return (
    <div className="expense-item">
      <div>{expenseDate.toISOString()}</div>
      <div className="expense-item__description">
        <h2>{expenseTitle}</h2>
        <div className="expense-item__price">${expenseAmount}</div>
      </div>
    </div>
  );
}

export default ExpenseItem;
```

Above we use JS variables in JS, this simple example demonstrate how we can potentially run JS to fetch data from a DB or transform data for use by a component.

### Dynamic Data via arguments

In JS or any language really, we make function reusable by passing arguments. React has this this same feature in components where we can pass variables vai '**Props'** to our components.

ðŸ¦€Like HTML elements can have attributes, our React component have attributes we can use these attributes to pass data to our components ðŸ¦€

``` {.javascript}
import ExpenseItem from "./components/ExpenseItem";

function App() {
  const expenses = [
    {
      id: 'e1',
      title: 'Toilet Paper',
      amount: 94.12,
      date: new Date(2020, 7, 14),
    },
    { id: 'e2', title: 'New TV', amount: 799.49, date: new Date(2021, 2, 12) },
    {
      id: 'e3',
      title: 'Car Insurance',
      amount: 294.67,
      date: new Date(2021, 2, 28),
    },
    {
      id: 'e4',
      title: 'New Desk (Wooden)',
      amount: 450,
      date: new Date(2021, 5, 12),
    },
  ];
  
  return (
    <div>
      <h2>Let's get started!</h2>
      <ExpenseItem
        title={expenses[0].title}
        amount={expenses[0].amount}
        date={expenses[0].date}
      />
      <ExpenseItem
        title={expenses[1].title}
        amount={expenses[1].amount}
        date={expenses[1].date}
      />
      <ExpenseItem
        title={expenses[2].title}
        amount={expenses[2].amount}
        date={expenses[2].date}
      />
      <ExpenseItem
        title={expenses[3].title}
        amount={expenses[3].amount}
        date={expenses[3].date}
      />
    </div>
  );
}

export default App;
```

Above we pass data into our Components via attributes. Now that is only half, now we need to use these data in components. ðŸ¦€ **React will pass all these attributes to our component as an object with all of the received attributes as properties**; this object is often referred to as **props ðŸ¦€**Below we edit first component to use the data passed in via attributes.

``` {.javascript}
import './ExpenseItem.css';

function ExpenseItem(props) {
  return (
    <div className="expense-item">
      <div>{props.date.toISOString()}</div>
      <div className="expense-item__description">
        <h2>{props.title}</h2>
        <div className="expense-item__price">${props.amount}</div>
      </div>
    </div>
  );
}

export default ExpenseItem;
```

### Splitting Components into Multiple Files

Below we add some functionality (Date formatting) into our first component:

``` {.javascript}
import './ExpenseItem.css';

function ExpenseItem(props) {
  const month = props.date.toLocaleString('en-US', { month: 'long' });
  const day = props.date.toLocaleString('en-US', { day: '2-digit' });
  const year = props.date.getfullYear();

  return (
    <div className="expense-item">
      <div>
        <div>{month}</div>
        <div>{day}</div>
        <div>{year}</div>
      </div>
      <div className="expense-item__description">
        <h2>{props.title}</h2>
        <div className="expense-item__price">${props.amount}</div>
      </div>
    </div>
  );
}

export default ExpenseItem;
```

It works, but notice as we add functionality it also increases the complexity of the code. In this case to increase maintainability **we need to separate our concerns.** We can split some functionality into its own component, namely the date formatting; we will create a second component ExpenseDate to do this:

``` {.javascript}
import './ExpenseDate.css';

function ExpenseDate(props) {
  const month = props.date.toLocaleString('en-US', { month: 'long' });
  const day = props.date.toLocaleString('en-US', { day: '2-digit' });
  const year = props.date.getFullYear();

  return (
      <div className="expense-date">
        <div className="expense-date__month">{month}</div>
        <div className="expense-date__day">{day}</div>
        <div className="expense-date__year">{year}</div>
      </div>
  );
}

export default ExpenseDate;
```

Note we create and import a css file to style the calender like component. In our ExpenseItem component we just import and call this component, while funneling in the props data. The final product looks much nicer and the codebase has clear separation of concerns ([commit](https://github.com/rl627/udemy-react-js-academind/commit/d35b2a02f8ae56d1b44200c7212f539412f62eb4)).

ðŸ¦€How we type signals what type of code/file. Components always have capital first letter then camel case. One way to organize our css is that CSS classes should all be lower case separate by dashes and classes within a component should be indicated by "\_\_" as shown below ðŸ¦€

``` {.css}
.expense-date {
  display: flex;
  flex-direction: column;
  width: 5.5rem;
  height: 5.5rem;
  border: 1px solid #ececec;
  background-color: #2a2a2a;
  color: white;
  border-radius: 12px;
  align-items: center;
  justify-content: center;
}

.expense-date__month {
  font-size: 0.75rem;
  font-weight: bold;
}

.expense-date__year {
  font-size: 0.75rem;
}

.expense-date__day {
  font-size: 1.5rem;
  font-weight: bold;
}
```

### "Composition" of "children props"

Up until now we have only been passing attributes to our components (thus we can use self closing tags), but we can also pass HTML or other components as children props as below.

``` {.javascript}
<Card> <ExpenseList/> </Card>
```

This is particularly useful when we want to apply **separationg of concerns** when it comes to css styling.

![](images/composition_figure.PNG){width="100"}

For example for example see our current layout (snip above) we can see that many components (calendar, price, expense item and expense list) share a common card-like styling of rounded borders which is currently duplicated in css. We extract the shared styling of container divs into a seperate component.

``` {.javascript}
import "./Card.css";

function Card(props) {
  const classes = 'card ' + props.className;
  return <div className={classes}>{props.children}</div>;
}
 
export default Card;
```

Not this component takes a special attribute of props **(props.children)** which is what ever is between the JSX tags when called. We extract duplicated css to Card.css. For these shell components it is important to append the passed in classNames to the component classes. Then in our other components we implement this shell component ([commit](https://github.com/rl627/udemy-react-js-academind/commit/806c93e8715c022afc3a2d29a5c0300ffdf6d184)) by replacing the div tags where we wanted to add card styling (psuedo-code below).

``` {.javascript}
// Original
<Div className="expense-item">
  Card Content
</Div>

// Shell component
<Card className="expense-item">
  Card Content
</Card>
```

### Organizing Components File

We can use sub folders in ./Component to group components of similar features for examples: a folder for UI or another folder for the expenses feature ([commit](https://github.com/rl627/udemy-react-js-academind/commit/90d341177ff506bc48c49731bdaf8da8f6ef5e24)). We just need to update the import directories when needed. Folder structure has no rule but use sub-folders/nesting as needed to keep everything organized

ðŸ¦€We can use arrow function to define components ([commit](https://github.com/rl627/udemy-react-js-academind/commit/80118ad0efa17e398c980886add37c09f7c7f720))ðŸ¦€

# User Interaction & State

So far we covered basic React imperative declarations for a static UI; what about interactions? Here we cover

-   Handling Events

-   Updating UI & Working with "State"

-   Closer look at Components and State

### Listening to Events & Working with Event Handlers

To learn about state and events, lets do a simple demo. Add a button to each ExpenseItem and change the title when it is clicked. Each HTML element has a set of events that can occur (for example the 'onClick' event is available for almost all elements).

In React/JSX, the event available to each event can be called as an attribute which is then passed in a function that runs when the event occurs. Unlike the imperative approach where we have manually attach things, here we simply declare that we can to run clickHandler when this button is clicked! ðŸ˜ƒ

``` {.javascript}
<button onClick={clickHander}>Change Title</button>
```

ðŸ¦€event hander functions should usually end with "Handler" e.g. functionNameHandler. ðŸ¦€

### useState()

``` {.javascript}
const ExpenseItem = (props) => {

  let title = props.title;

  const clickHander = () => {console.log('clickHander')}

  return (
    <Card className="expense-item">
      <ExpenseDate date={props.date} />
      <div className="expense-item__description">
        <h2>{title}</h2>
        <div className="expense-item__price">${props.amount}</div>
      </div>
      <button onClick={clickHander}>Change Title</button>
    </Card>
  );
}
```

We update our ExpenseItem component to have a click handler to should change title but why doesn't it work? React executes the tree of component functions called in index.js just once. While the function to update is there React doesn't run this code yet.

ðŸ¦€Regular variables in component functions such as title doesn't trigger reevaluation. **State** in React are special type of variable which if change leads to component function reevaluation

ðŸ¦€States are created with useState() function/hook. React functions/hooks must be called within component functions ðŸ¦€

ðŸ¦€useState() create an Array with two elements; 1value is the value it self, second element is the update function.

Below we import useState(), the use destructuring with useState() to implement the reevaluation nd update of title.. Now upon click there is a change in state and this component function is reevaluated and updates! ([commit](https://github.com/rl627/udemy-react-js-academind/commit/3bd95804383eb67b94e623832070343c3f447a4f)).

``` {.javascript}
import { useState } from 'react';
import Card from '../UI/Card';
import ExpenseDate from './ExpenseDate';
import './ExpenseItem.css';

const ExpenseItem = (props) => {
  
  const [title, setTitle] = useState(props.title);

  const clickHander = () => setTitle("New Title")

  return (
    <Card className="expense-item">
      <ExpenseDate date={props.date} />
      <div className="expense-item__description">
        <h2>{title}</h2>
        <div className="expense-item__price">${props.amount}</div>
      </div>
      <button onClick={clickHander}>Change Title</button>
    </Card>
  );
}

export default ExpenseItem;
```

**ðŸ¦€If you have data which might change and where changes to that data should be reflected in the UI then you need state; because regular variables will not trigger reevaluation of the component function.ðŸ¦€**

### User Input

Lets first create an Input section where users can create new Expense Items. We apply component basics to generate a user form in this [commit](https://github.com/rl627/udemy-react-js-academind/commit/6c7e1ff66e87c75849ad00098af4ec67d9363be0). Now want to be able to detect when there is a change in input.

ðŸ¦€Event handlers in component functions have access to event similar to vanilla JS eventListenersðŸ¦€

ðŸ¦€useState() allows use to store input data detached from the reevaluation life cycle of a component functionðŸ¦€

Below we use Event handlers and the useState() to store inputs in multiple multiples states in the ExpenseForm component function. ([commit](https://github.com/rl627/udemy-react-js-academind/commit/cca41b836efc29317f7afac122195c3d33b92fbb))

``` {.javascript}
import { useState } from 'react';
import "./ExpenseForm.css";

export default function ExpenseForm() {
  const [enteredTitle, setEnteredTitle] = useState('');
  const [enteredAmount, setEnteredAmount] = useState('');
  const [enteredDate, setEnteredDate] = useState('');

  const titleChangeHandler = (event) => {
    setEnteredTitle(event.target.value);
   }
  
  const AmountChangeHandler = (event) => {
    setEnteredAmount(event.target.value);
  }

  const DateChangeHandler = (event) => {
      setEnteredDate(event.target.value);
  };
  
  return (
    <form className="new-expense__controls">
      <div className="new-expense__control">
        <label>Title</label>
        <input type="text" onClick={titleChangeHandler} />
      </div>
      <div className="new-expense__control">
        <label>Amount</label>
        <input
          type="number"
          min="0.1"
          step="0.01"
          onClick={AmountChangeHandler}
        />
      </div>
      <div className="new-expense__control">
        <label>Date</label>
        <input
          type="date"
          min="2019-01-01"
          max="2022-12-31"
          onClick={DateChangeHandler}
        />
      </div>
      <div className="new-expense__actions">
        <button type="submit">Add Expense</button>
      </div>
    </form>
  );
}
```

ðŸ¦€When ever you update state and you depend on the previous state (e.g. a counter) **you should use special argument prevState to refer to the previous state in your updater**. ðŸ¦€

This is because update isn't instant and you could potentially refer to an outdated State if you don't specify previous state. See below for

``` {.javascript}
setUserInput((prevState) => {
  return {...prevState, enteredTitle: event.target.value}
})
```

Now that we have stored data, we can deal with for submission but not that ðŸ¦€By default if a button in a form is clicked, that form will emit a form submission event which automatically reloads the page because the browser sends a request to the server hosting the web page. ðŸ¦€

ðŸ¦€State have two-way binding; we can not only listen to update but we can also pass new values back into the input ðŸ¦€

Below we add an event handler to onSubmit for the form which does three things: 1) prevent default reload 2) gather the entered data 3) clear inputs using two way binding. ([commit](https://github.com/rl627/udemy-react-js-academind/commit/6ebed745e3da80a3c720d6971fd812f4a24655fc))

``` {.javascript}
import { useState } from 'react';
import "./ExpenseForm.css";

export default function ExpenseForm() {
  const [enteredTitle, setEnteredTitle] = useState('');
  const [enteredAmount, setEnteredAmount] = useState('');
  const [enteredDate, setEnteredDate] = useState('');

  const titleChangeHandler = (event) => {
    setEnteredTitle(event.target.value);
   }
  
  const AmountChangeHandler = (event) => {
    setEnteredAmount(event.target.value);
  }

  const DateChangeHandler = (event) => {
      setEnteredDate(event.target.value);
  };
  
  const submitHandler = (event) => {
    event.preventDefault();

    const expenseData = {
      title: enteredTitle,
      amount: enteredAmount,
      date: enteredDate
    }

    setEnteredTitle('');
    setEnteredAmount('');
    setEnteredDate('');

    console.log(expenseData);
  }

  return (
    <form onSubmit={submitHandler}>
      <div className="new-expense__controls">
        <div className="new-expense__control">
          <label>Title</label>
          <input
            type="text"
            value={enteredTitle}
            onChange={titleChangeHandler}
          />
        </div>
        <div className="new-expense__control">
          <label>Amount</label>
          <input
            type="number"
            min="0.1"
            step="0.01"
            value={enteredAmount}
            onChange={AmountChangeHandler}
          />
        </div>
        <div className="new-expense__control">
          <label>Date</label>
          <input
            type="date"
            min="2019-01-01"
            max="2022-12-31"
            value={enteredDate}
            onChange={DateChangeHandler}
          />
        </div>
        <div className="new-expense__actions">
          <button type="submit">Add Expense</button>
        </div>
      </div>
    </form>
  );
}
```

### Child-to-Parent Component Communication (Bottom-up)

ðŸ¦€"**Lifting State up**" is a pattern where we transfer state from child to parent by using props to receive a function a parent component which is called in the child component .ðŸ¦€

We can pass data from child to parent by passing a prop function from parent to child which uses data collected by the child While props are used to pass data downward from parent to child (Top-to-Bottom), we now wanted to pass data from Child to Parent (bottom-up) from data collected in ExpenseForm to App.

Here we lift the state of the submitted data from the ExpenseForm component to NewExpense to App ([commit](https://github.com/rl627/udemy-react-js-academind/commit/d1c1388b05b041d5624c1feed017caf459291496)).

### Assignment 2

Goal is to add a filter component add into the ExpenseList component which allows us to filter by Years. This data (selected year) should be lifted up to the ExpenseList component and stored as state. We accomplish this by doing the following ([commit](https://github.com/rl627/udemy-react-js-academind/commit/eb6b8bd5dfeac3be7751311ff53ee621a1631872)):

-   Creating the ExpensesFilter Component + CSS

-   From the ExpenseList (Parent) we pass to ExpensesFilter (Child) a prop function which uses the selected year. This prop function will update a state create to track year.

-   Within ExpensesFilter (Child), we add a onChanrge handler for the selection element which calls the prop function from the parent.

-   Optional: use two-way binding to ensure that the selected filter Year value is the current state.

### Vocab review (Controlled/Uncontrolled, Stateful/Stateless)

In this module we learned two-way binding and thus create what React calls a **'Controlled Component**'; a controlled component uses a value which is not only passed on to the parent component but also received from the parent component. For example, ExpensesFilter's year value is passed onto and received from ExpenseList; here, both the set value and the selected value is not part of ExpensesFilter and the real logic resides in the parent component.

**Presentation/dumb/stateless** vs **Stateful/Smart** components. We have components that manage state (such as ExpenseForm which manages the input state) then we have other components which don't have any internal state (ExpenseItem) and are just there to display data. In most React apps we have more stateless components than Stateful. Because we want to split our application into small reusable pieces; most pieces will focus on outputting things and only a few components which manage state; these state are distributed via props.
